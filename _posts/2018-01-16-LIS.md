---
layout: post
title: "최대 증가 부분 수열"
description: "ID : LIS"
date: 2017-07-12
tags: [ 알고리즘, 알고스팟, 프로그래밍 대회에서 배우는 알고리즘 문제해결전략, dynamic programming]
comments: true
share: true

---

LIS 문제는 간단하지만 완전 탐색에 관해서 정리를 하게 해준다. 이 문제의 포인트는 하나이다.

* 증가 부분 수열의 최대 값을 어떻게 구할 것인가.

색다른 방법은 없어 보였다. 그냥 전체 경우의 수를 구한 다음 그 중에서 최댓값을 찾아야겠다고 생각했다.

### 잘못 접근한 코드를 보자
    int find_MAX(int idx, int val) {

        if(idx == num)
            return 1;

        int& ret = cache[idx][val];
        if(ret != -1) return ret;

        ret = find_MAX(idx + 1, val);

        if(idx + 1 < num)
            if(a[idx] > val)
                ret = max(ret, 1 + find_MAX(idx + 1, a[idx]));

        return ret;
    }
    
코드를 보면 입력받은 index를 전부 체크하면서 해당 index를 포함했을 때와 그냥 넘어갔을 때를 나눴다. 그리고 포함을 했다면 그 값을 같이 넘겼다. 그래야 다음 차례에서 그 값을 가지고 비교를 할 수 있기 때문이다.
하지만 **이 코드는 틀린 코드이다. 해당 index를 포함했을 때, 이 값을 같이 넘겨줘야 한다. 그렇다면 완전탐색에서 중요한 cache배열의 크기가 엄청나게 커진다.** 만약 수열에 주어진 값의 범위가 굉장히 크다면 배열조차 못 만들기 때문이다.

### 정답이 나온 코드를 보자
    
    int find_MAX(int idx) {

        int& ret = cache[idx];
        if(ret != -1) return ret;

        ret = 1;

        for(int i = idx + 1; i < num; i++)
            if(a[idx] < a[i])
                ret = max(ret, 1 + find_MAX(i));

        return ret;
    }
        
그래서 생각한 방법은 해당 index의 값을 포함한다고 생각하지 않고, **해당 index를 포함할 때 나머지 부분을 쪼개서 생각했다.** 그러면 이 index의 값보단 커야하기 때문에 한개의 for문 안에 재귀를 넣어서 깔끔하게 구할 수 있다. 답을 내기 위해선 출력전에 for문 한번 더 돌려서 모든 index를 체크해야 한다.

    int answer = 0;

    for(int i = 0; i < num; i++)
        answer = max(answer, find_MAX(i));
            
이 문제를 풀면서 완전 탐색에 대해 다시 한번 생각하게 됬다. **전체를 구해야 할 때 쪼개서 생각하는 습관을 들여야 겠다. **
다음은 책에 있는 동적 계획법 레시피이다. 참고를 해도 나쁘지 않을 것 같다.

### 최적화 문제 동적 계획법 레시피
> 1. 모든 답을 만들어 보고 그중 최적해의 점수를 반환하는 완전 탐색 알고리즘을 설계
> 2. 전체 답의 점수를 반환하는 것이 아니라, 앞으로 남은 선택들에 해당하는 점수만을 반환하도록 부분 문제 정의를 바꿈.
> 3. 재귀 호출의 입력에 이전의 선택에 관련된 정보가 있다면 꼭 필요한 것만 남기고 줄임. 여기서 목표는 중복된 부분 문제를 많이 만드는 것. 입력의 종류가 줄어들면 줄어들수록 더 많은 문제가 중복되기 때문.
> 4. 입력이 배열이나 문자열인 경우 적절한 변환을 통해 메모제이션을 이용
> 5. 메모제이션 적용


