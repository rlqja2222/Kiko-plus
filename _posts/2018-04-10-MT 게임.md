---
layout: post
title: "MT 게임"
description: "ID : scpc 1회 예선(번호 : 16)"
date: 2018-04-10
tags: [알고리즘, scpc 1회 예선, scpc]
comments: true
share: true

---

[MT 게임](https://www.codeground.org) 문제는 scpc 1회 예선 문제이다. 문제의 포인트는 간단하다.
* a, b, N, K가 주어지고(a >= b), A팀이 먼저 시작할때 누가 이기는지 규칙 찾기

흔히 술자리에서 하는 베스킨라빈스 게임과 비슷하다. 베스킨라빈스의 원리를 한번 알아보자. 둘이서 게임을 하게 될 때, 1부터 시작해서 31을 먼저 말하는 사람이 게임에서 패배한다. 상대가 31을 말하게 할려면 어떻게 해야할까?  
**내가 30까지 부를 수 있으면 된다.** 내가 30을 부를려면 26을 마지막으로 불러야 한다. 즉 이 게임에서는 **상대방이 내가 조종할수 있도록 숫자를 부르면 된다.** 상대방은 1개, 2개, 3개 까지 부를 수 있고 나 또한 1개, 2개, 3개를 부를 수 있다. 그럼 상대방이 1개를 불렀을 땐 내가 3개, 2개를 불렀을땐 내가 2개, 3개를 불렀을땐 내가 1개를 부름으로써 한번의 턴을 4개로 맞출 수 있다.   
즉 30을 불러야 하는 나는 `30 % 4 = 2` 이므로 처음에 2까지 부를수만 있다면 무조건 이기게 된다. 그 뒤로는 계속 합이 4를 맞춰가며 부르면 되니.  
이 문제에 어떻게 적용을 할까
* A가 먼저 시작하며, B 보다 많거나 같은 수를 가지고 있다.
* A가 먼저 시작하므로 A가 조종을 할 수 있다.
* A가 이길 수 있는 경우를 먼저 탐색하고, 없으면 B가 이기는 것으로 한다.

첫번쨰로, 조종할 수 있는 수를 찾아야 한다. 베스킨라빈스 게임에서는 4로 햇지만, 여기서는 여러가지 수가 존재할 수 있다. 간단히 계산을 해보면 `a >= b`이고 A팀이 한턴에 낼수 있는 수는 a부터 aK이고 B팀은 b부터 bK이다. 이 수를 set수라고 한다면 set수는 `a + bK ~ b + aK` 가 된다. 그리고 A는 N-b-1부터 N-1까지만 말하면 무조건 이기므로 set수로 말해야하는 수들을 나눴을때, A가 처음 turn 에 말할수만 있다면 그 게임은 이기게 된다.

### 일단 코드를 보자
	int T;
	cin >> T;
	for (int test_case = 1; test_case < T + 1; test_case++) {
  		cin >> a >> b >> c;
  		cout << "Case #" << test_case << endl;
  		for(int c_case = 0; c_case < c; c_case++) {
  			cin >> N >> K;
  			bool a_flag =  false;	//a가 이기는지 확인
  			for (int total = a + b*K; total <= b + a*K; total++) {
				for (int temp = N - b - 1; temp < N; temp++) {
					if ((temp % total) >= a && (temp % total) <= a * K) {
						a_flag = true;
  						break;  				
  					}
  				}
  				if(a_flag)
  					break;
  			}
  			if (a_flag)
  				cout << 'a';
  			else
  				cout << 'b';
		}
		cout << endl;
	}


코드는 생각보다 간단하다. baekjoon의 scpc해설에서는 누적합을 통해 이길수 있는지를 계산했다. 방법자체는 다르지만 dp를 써서 푸는 것도 색다른 방법이었다.
