---
layout: post
title: "균일수"
description: "ID : scpc 1회 예선(번호 : 13)"
date: 2017-09-24
tags: [알고리즘, scpc 1회 예선, scpc]
comments: true
share: true

---

[균일수](https://www.codeground.org) 문제는 scpc 1회 예선 문제이다. 문제의 포인트는 간단하다.
* 균일수가 되는 기저값의 최소를 구하라

일단 균일수가 무엇인지 파악을 했다. N = aa..a(b)로 주어진 N이 표현될 때, b의 최솟값을 구하는 것이다.
그래서 일단 무작정 구하는 코드를 짜봤다.

### 무작정 구한 코드를 보자
    int N, temp, a;
    cin >> N;
    int b = 2;
    while(b < N){
        temp = N / b;
        a = num % b;

        while(temp > b){
            if(temp % b != a){
                b++;
                break;
            }
            temp /= b;
        }
        if(temp == a)
            break;
        b++;
    }
        
N에 대해서 b를 계속해서 나눠보는 것이다. 그리고 균일수로 표현이 안되면 다음 수로 차례차례 구했다. 답은 구해진다. 하지만 시간초과가 뜨며 점수는 150점 중에 100점밖에 받지 못한다. 어떻게하면 시간을 줄일수 있을까

문제를 다시 한번 읽어보자.
1. 자연수 N이 하나 이상의 기저에 대해 균일수가 된다면 그 기저들 중 가장 작은값을 구하라.
2. b > N이라면 b진법에 의해 한자리 수가 되는데 이때도 균일수로 간주.

여기서 전체를 구해선 절대 시간을 줄일 수 없다. 또한 중복되는 결과가 나오지도 않는다. **그렇다면 검사를 하는 범위를 줄여야 한다.**

예제를 천천히 써보았다.

	36 = 2,2(17)
	   = 44(8)
   
공식화를 시켜보면
	
    N = a(1 + b)
   
진법에 따라 a는 b 보다 작아야한다. 그러므로 a < sqrt(N) < b가 된다.
하나가 더 증가해도 맞는지 확인해보자.
	
    N = a(1 + b + b^2)
    if a == 1
    N = b^2 + b + 1
    b^2 < b^2 + b + 1 < N
    
범위만 확인하면 되므로, b가 가장 클 때 즉 a = 1일때를 보자. 위의 식처럼 N = b^2+b+1이므로 b는 루트 N 보다 작게 된다. a가 증가하면 b는 당연히 작아지므로 b가 루트 N보다 작은것은 자명해진다.
마지막으로 문제에서 b > N이라면 b진법에 한자리수가 될때를 구해주면 경우의 수는 3가지가 된다.
시간을 조금이라도 더 줄이기 위해
2번째 경우를 먼저 구해보고 없다면 1번째 그다음 세번째 경우를 구하면 된다.

### 이제 pass한 코드를 보자
	cin >> N;
    int b;
    int ans = -1;
    //n > 2 일때 최소 기저값 : N = a(b^n-1 + b^n-2 + .... + b + 1) 형태일때
    for(b = 2; b*b < N; b++){
        int temp = N / b;
        int a = N % b;
        while(temp > b){
            if(temp%b != a)
                break;
            temp /= b;
        }
        //찾았을때
        if(temp == a){
            ans = b;
            break;
        }
    }
	//n = 2 일때 최소 기저값 : N = a(b+1) 형태일때
    if(ans == -1){
        for(int a = sqrt(N); a > 0; a--)
            if((N-a)%a == 0) {
                b = (N-a)/a;
                if(b <= a)
                    continue;
                ans = b;
                break;
            }
    }

    if(ans == -1)
        ans = N + 1;
        
어떠한 알고리즘을 쓰는 문제는 아니였지만, 시간을 줄이기 위해 최소한의 경우의 수를 나눴다. 이쯤와서 생각해보니 문제에 접근하는 방법에 어느정도 기준이 있다는 것을 알았다.
* 완전탐색으로 접근
* 완전탐색이라면 어떻게 시간을 줄일것인가 (중복 줄이기, 범위 좁히기)
* 완전탐색이 아니라면 매순간 최선의 선택을 어떻게 구할것인가
* 해결책이 보이지 않는다면 문제를 다시 한번 읽고 예제를 다시 풀어본다.

이정도 메뉴얼을 가지고 계속해서 문제에 접근을 해봐야겠다.